｛宿題｝｛しゅくだい｝2
=======================

この｛宿題｝｛しゅくだい｝は「プログラミングHaskell」の
｛第｝｛だい｝1～7｛章｝｛しょう｝を｛扱｝｛あつか｝っています。

｛問題｝｛もんだい｝1
---------------------

ワンタイムパッドとビットごとの｛排他的論理和｝｛はいたてきろんりわ｝（XOR）
｛暗号｝｛あんごう｝を｛用｝｛もち｝いることで、
｛第｝｛だい｝7｛章｝｛しょう｝で｛使｝｛つく｝った｛文字列｝｛もじれつ｝を
｛通信｝｛つうしん｝するプログラムを｛暗号｝｛あんごう｝で
｛通信｝｛つうしん｝するように｛変更｝｛へんこう｝せよ。
｛排他的論理和｝｛はいたてきろんりわ｝を｛計算｝｛けいさん｝する
｛関数｝｛かんすう｝`xor`を｛自分｝｛じぶん｝で｛定義｝｛ていぎ｝せよ。
｛短｝｛みじか｝すぎるワンタイムパッドで｛呼｝｛よ｝び｛出｝｛だ｝された
｛場合｝｛ばあい｝のために、リストの｛要素｝｛ようそ｝を
｛繰｝｛く｝り｛返｝｛かえ｝す｛関数｝｛かんすう｝`cycle`を｛使｝｛つか｝うと
｛良｝｛よ｝い。

http://ja.wikipedia.org/wiki/ワンタイムパッド

http://en.wikipedia.org/wiki/XOR_cipher

｛次｝｛つぎ｝の｛関数｝｛かんすう｝の｛型｝｛かた｝を｛変更｝｛へんこう｝
する。

* `encode :: String -> String -> [Bit]`
* `decode :: String -> [Bit] -> String`
* `transmit :: String -> String -> String`

｛以下｝｛いか｝の｛実行例｝｛じっこうれい｝で｛自分｝｛じぶん｝の
｛定義｝｛ていぎ｝が｛正｝｛ただ｝しいことを｛確認｝｛かくにん｝せよ。

    > encode "haskell" "abc"
    [1,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0]
    > decode "haskell" [1,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0]
    "abc"
    > decode "bad" [1,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0]
    "kbt"
    > transmit "TooShortOTP" "higher-order functions are easy"
    "higher-order functions are easy"

｛問題｝｛もんだい｝2
---------------------

リストの｛要素｝｛ようそ｝で、｛自身｝｛じしん｝と｛自身｝｛じしん｝の
ひとつ｛前｝｛まえ｝の｛要素｝｛ようそ｝が｛与｝｛あた｝えられた
｛条件｝｛じょうけん｝を｛満｝｛み｝たすものだけを｛返｝｛かえ｝す
｛関数｝｛かんすう｝を｛考｝｛かんが｝える。ただし｛先頭｝｛せんとう｝の
｛要素｝｛ようそ｝は｛必｝｛かなら｝ず｛返｝｛かえ｝されるものとする。
これをリスト｛内包｝｛ないほう｝｛表記｝｛ひょうき｝を｛用｝｛もち｝いて
｛実装｝｛じっそう｝した、`relFiltLC`を｛定義｝｛ていぎ｝せよ。
｛以下｝｛いか｝｛同様｝｛どうよう｝に｛再帰｝｛さいき｝を｛用｝｛もち｝いて、
`relFiltER`を｛定義｝｛ていぎ｝せよ。｛高階関数｝｛こうかいかんすう｝を
｛用｝｛もち｝いて、`relFiltHO`を｛定義｝｛ていぎ｝せよ。

｛以下｝｛いか｝の｛実行例｝｛じっこうれい｝で｛自分｝｛じぶん｝の
｛定義｝｛ていぎ｝が｛正｝｛ただ｝しいことを｛確認｝｛かくにん｝せよ。

    > relFiltLC (>) [3,1,4,1,5,9,2,6,5]
    [3,4,5,9,6]
    > relFiltLC (<) "hackyskewlol"
    "haskell"
    > relFiltER (>) [3,1,4,1,5,9,2,6,5]
    [3,4,5,9,6]
    > relFiltER (<) "hackyskewlol"
    "haskell"
    > relFiltHO (>) [3,1,4,1,5,9,2,6,5]
    [3,4,5,9,6]
    > relFiltHO (<) "hackyskewlol"
    "haskell"

｛問題｝｛もんだい｝3
---------------------

｛文字列｝｛もじれつ｝のAlder-32チェックサムを｛計算｝｛けいさん｝する
｛関数｝｛かんすう｝`adler32 :: String -> String`を｛定義｝｛ていぎ｝せよ。
チェックサムを16｛進数｝｛しんすう｝で｛返｝｛かえ｝せ。

http://ja.wikipedia.org/wiki/Adler-32

｛以下｝｛いか｝の｛実行例｝｛じっこうれい｝で｛自分｝｛じぶん｝の
｛定義｝｛ていぎ｝が｛正｝｛ただ｝しいことを｛確認｝｛かくにん｝せよ。

    > adler32 "Wikipedia"
    "11E60398"
    > (adler32 . take 10000 . cycle) "haskell"
    "D8E52268"

もっと｛大｝｛おお｝きい｛文字列｝｛もじれつ｝で｛計算｝｛けいさん｝したら、
｛作｝｛つく｝った｛関数｝｛かんすう｝が｛特｝｛とく｝に｛遅｝｛おそ｝いことに
｛気付｝｛きづ｝くはずだ。｛理由｝｛りゆう｝はいくつかありえるが
、｛一｝｛ひと｝つは`String`を｛使｝｛つか｝っていることだ。
`String`がリストで｛作｝｛つく｝られているデータ｛構造｝｛こうぞう｝だから
｛遅｝｛おそ｝い。`Data.ByteString`などは｛早｝｛はや｝い。

｛問題｝｛もんだい｝4
---------------------

ニュートン｛法｝｛ほう｝を｛使｝｛つか｝って、｛与｝｛あたえ｝えられた
｛精度｝｛せいど｝で｛値｝｛あたい｝の｛乗根｝｛じょうこん｝を
｛計算｝｛けいさん｝する｛関数｝｛かんすう｝を｛定義｝｛ていぎ｝せよ。
（｛現実的｝｛げんじつてき｝な｛実装｝｛じっそう｝は｛精度｝｛せいど｝を
｛有効桁｝｛ゆうこうけた｝で｛計算｝｛けいさん｝し
｛浮動小数点｝｛ふどうしょうすうてん｝の｛型｝｛かた｝のハッキングが
｛必要｝｛ひつよう｝だがこの｛問題｝｛もんだい｝では｛気｝｛き｝にしない
｛方｝｛ほう｝が｛良｝｛よ｝い。）

http://ja.wikipedia.org/wiki/ニュートン法

    nroot :: Double  -- Δ
          -> Double  -- ｛値｝｛あたい｝
          -> Int     -- ｛次数｝｛じすう｝
          -> Double  -- ｛乗根｝｛じょうこん｝

｛以下｝｛いか｝の｛実行例｝｛じっこうれい｝で｛自分｝｛じぶん｝の
｛定義｝｛ていぎ｝が｛正｝｛ただ｝しいことを｛確認｝｛かくにん｝せよ。

    > nroot 0.0000001 2 2
    1.4142135623730951
    > nroot 0.0000001 2 3
    1.2599210498948732
    > nroot 0.1 2 2
    1.4166666666666667
    > nroot 0.1 2 3
    1.2609322247417485
    > nroot 1 2 2
    1.5
    > nroot 0.0001 1331 3
    11.000000000000142
    > nroot 0.0001 123456789 6
    22.314431636474602
    > nroot 0.0001 0.0001 6
    0.2154434765980944
    > nroot 0.0001 (-2) 3
    -1.2599210498953948
    > nroot 0.0001 (-2) 2
    *** Exception: even root of negative

（｛精度｝｛せいど｝を｛保障｝｛ほしょう｝できない
｛可能性｝｛かのうせい｝がある。）
