補足演習問題：第7章
===================

_プログラミングHaskell_ の第7章のための補足演習問題です。本にある演習問題
（ページ87、88）を最初に解決してください。

問題10
------

下の関数をリスト内包表記の代わりに`filter`と`map`を使う関数に書き直せ。

    import Data.Char (isAsciiUpper, ord, toUpper)

    hoge :: String -> [Int]
    hoge xs = [ord x' + c | x <- xs, let x' = toUpper x, isAsciiUpper x']
      where
          c = 1 - ord 'A'

以下の実行例で自分の定義が正しいことを確認せよ。

    > hoge "Haskell!"
    [8,1,19,11,5,12,12]

問題11
------

クレジット・カードのチェックサムをLuhnアルゴリズムで確認する関数
`luhncheck :: String -> Bool`を定義せよ。数字以外の文字を無視して、すべての
書き方を許せ。`Data.Char`に定義している`digitToInt`と`isDigit`を使うと良い。

http://ja.wikipedia.org/wiki/Luhnアルゴリズム

以下の実行例で自分の定義が正しいことを確認せよ。

    > luhncheck "1234-5678-9012-3452"
    True
    > luhncheck "4417123456789113"
    True
    > luhncheck "4408 0412 3456 7890"
    False

問題12
------

リストのリストを取って、要素のリストを連結する関数`concat :: [[a]] -> [a]`を
第6章の演習問題で定義した。これを`foldr`を使って実装した関数`concatR`を定義せよ。
さらに、`foldl`を使って実装した関数`concatL`を定義せよ。

以下の実行例で自分の定義が正しいことを確認せよ。

    > concatR [[1,2],[3],[],[4,5]]
    [1,2,3,4,5]
    > concatL [[1,2],[3],[],[4,5]]
    [1,2,3,4,5]
    > concatR []
    []
    > concatL []
    []

どちらが良いと思うか？それは何故か？

問題13
------

第6章で二つの整列されたリストを一つの整列されたリストにする関数`merge`を定義
した。任意の数の整列されたリストを一つの整列されたリストにする関数`nmerge`を定義せよ。

以下の実行例で自分の定義が正しいことを確認せよ。

    > nmerge [[9],[2,5,7],[1,4],[],[3,6],[8]]
    [1,2,3,4,5,6,7,8,9]

問題14
------

`foldr`または`foldl`を使って、リストの中から与えられた条件を満たす要素の数を返す関数
`count :: (a -> Bool) -> [a] -> Int`を定義せよ。

以下の実行例で自分の定義が正しいことを確認せよ。

    > count (== 1) [1,2,1,3,4,1,5,1]
    4
    > count (\x -> x `mod` 2 == 0) [1,2,1,3,4,1,5,1]
    2
    > count id [True,False,True,True]
    3
