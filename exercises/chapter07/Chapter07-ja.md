補足演習問題：第7章
===================

_プログラミングHaskell_の第7章のための補足演習問題です。本にある演習問題
（ページ87、88）を最初に解決してください。

問題10
------

下の関数はリスト内包表記ではなくて`filter`と`map`を使っている関数に変換せよ。

    import Data.Char (isAsciiUpper, ord, toUpper)

    hoge :: String -> [Int]
    hoge xs = [ord x' + c | x <- xs, let x' = toUpper x, isAsciiUpper x']
      where
          c = 1 - ord 'A'

以下の実行例で自分の定義が正しいことを確認せよ。

    > hoge "Haskell!"
    [8,1,19,11,5,12,12]

問題11
------

クレジット・カードのチェックサムをLuhnアルゴリズムで確認する関数
`luhncheck :: String -> Bool`を定義せよ。数字以外の文字を無視して、すべての
書き方を許せよ。`Data.Char`に定義している`digitToInt`と`isDigit`を使うと良い。

http://ja.wikipedia.org/wiki/Luhnアルゴリズム

以下の実行例で自分の定義が正しいことを確認せよ。

    > luhncheck "1234-5678-9012-3452"
    True
    > luhncheck "4417123456789113"
    True
    > luhncheck "4408 0412 3456 7890"
    False

問題12
------

リストのリストを取って要素であるリストを連結する関数`concat :: [[a]] -> [a]`は
第6章の演習問題に定義した。`foldr`を使っている関数`concatR`を定義せよ。
さらに、`foldl`を使っている関数`concatL`を定義せよ。

以下の実行例で自分の定義が正しいことを確認せよ。

    > concatR [[1,2],[3],[],[4,5]]
    [1,2,3,4,5]
    > concatL [[1,2],[3],[],[4,5]]
    [1,2,3,4,5]
    > concatR []
    []
    > concatL []
    []

どちらが良い？何で？

問題13
------

第6章に二つの整列されたリストを一つの整列されたリストにする関数`merge`を定義
した。任意数の整列されたリストを一つの整列されたリストにする関数はどうやって
する？関数`nmerge`を定義せよ。

以下の実行例で自分の定義が正しいことを確認せよ。

    > nmerge [[9],[2,5,7],[1,4],[],[3,6],[8]]
    [1,2,3,4,5,6,7,8,9]

問題14
------

`foldr`か`foldl`を使って、リストの中から述語を満たす要素の数を返す関数
`count :: (a -> Bool) -> [a] -> Int`を定義せよ。

以下の実行例で自分の定義が正しいことを確認せよ。

    > count (== 1) [1,2,1,3,4,1,5,1]
    4
    > count (\x -> x `mod` 2 == 0) [1,2,1,3,4,1,5,1]
    2
    > count id [True,False,True,True]
    3
