｛補足｝｛ほそく｝｛演習｝｛えんしゅう｝｛問題｝｛もんだい｝：｛第｝｛だい｝4｛章｝｛しょう｝
=============================================================================================

_プログラミングHaskell_の｛第｝｛だい｝4｛章｝｛しょう｝のための
｛補足｝｛ほそく｝｛演習｝｛えんしゅう｝｛問題｝｛もんだい｝です。
｛本｝｛ほん｝にある｛演習｝｛えんしゅう｝｛問題｝｛もんだい｝
（ページ43、44）を｛最初｝｛さいしょ｝に｛解決｝｛かいけつ｝してください。

｛問題｝｛もんだい｝7
---------------------

｛何｝｛なん｝で｛以下｝｛いか｝のが｛無効｝｛むこう｝ですか？

    if 1 then 'a' else 'b'

｛問題｝｛もんだい｝8
---------------------

｛何｝｛なん｝で｛以下｝｛いか｝のが｛無効｝｛むこう｝ですか？

    if True then 1 else 'b'

｛問題｝｛もんだい｝9
---------------------

`(:)`という*cons｛演算子｝｛えんざんし｝*は｛既存｝｛きぞん｝のリストの
｛先頭｝｛せんとう｝に｛新｝｛あたら｝しい｛要素｝｛ようそ｝を
｛追加｝｛ついか｝します。`(++)`という*｛連結｝｛れんけつ｝
｛演算子｝｛えんざんし｝*は｛二｝｛ふた｝つのリストを｛連結｝｛れんけつ｝
します。GHCiで`:t (:)`と`:t (++)`を｛使｝｛つか｝って、これらの
｛関数｝｛かんすう｝の｛型｝｛かた｝を｛確認｝｛かくにん｝してください。

これらの｛関数｝｛かんすう｝を｛理解｝｛りかい｝するのを｛確認｝｛かくにん｝
するために、すべての｛引数｝｛ひきすう｝の｛値｝｛あたい｝を
｛順番｝｛じゅんばん｝にして、リストを｛作｝｛つく｝る｛関数｝｛かんすう｝を
｛実装｝｛じっそう｝してください：

    hoge :: a -> [a] -> a -> [a] -> [a] -> (a, a) -> [a]

｛以下｝｛いか｝の｛使用例｝｛しようれい｝を｛示｝｛しめ｝してください。

    > hoge 1 [2,3] 4 [5] [6,7] (8,9)
    [1,2,3,4,5,6,7,8,9]
    > hoge 1 [] 2 [] [] (3,4)
    [1,2,3,4]

｛問題｝｛もんだい｝10
----------------------

`Data.List`モジュールに｛定義｝｛ていぎ｝されている`isPrefixOf`
｛関数｝｛かんすう｝はあるリストが｛他｝｛ほか｝のリストの
｛開始｝｛かいし｝｛部分｝｛ぶぶん｝に｛一致｝｛いっち｝するかを
｛検査｝｛けんさ｝します：

    isPrefixOf :: Eq a => [a]   -- リスト1
                       -> [a]   -- リスト2
                       -> Bool  -- リスト2の｛開始｝｛かいし｝がリスト1？

｛第｝｛だい｝2｛章｝｛しょう｝で｛紹介｝｛しょうかい｝した
｛関数｝｛かんすう｝を｛使｝｛つか｝って、`isPrefixOf`を｛実装｝｛じっそう｝
してください。

｛同｝｛おな｝じように`isSuffixOf`を｛実装｝｛じっそう｝してください。

    isSuffixOf :: Eq a => [a]   -- リスト1
                       -> [a]   -- リスト2
                       -> Bool  -- リスト2の｛終了｝｛しゅうりょう｝がリスト1？

｛以下｝｛いか｝の｛使用例｝｛しようれい｝を｛示｝｛しめ｝してください。

    > [1,2] `isPrefixOf` [1,2,3,4]
    True
    > [3,4] `isSuffixOf` [1,2,3,4]
    True
    > [4] `isPrefixOf` [1,2,3,4]
    False
    > [1] `isSuffixOf` [1,2,3,4]
    False
    > [] `isPrefixOf` [1,2,3,4]
    True
    > [] `isSuffixOf` [1,2,3,4]
    True
    > [1] `isPrefixOf` []
    False
    > [1] `isSuffixOf` []
    False

｛問題｝｛もんだい｝11
----------------------

パターンマッチを｛使｝｛つか｝って、`nand`と`nor`という｛基準｝｛きじゅん｝
ブール｛演算｝｛えんざん｝を｛実装｝｛じっそう｝してください。｛好｝｛す｝きな
｛方法｝｛ほうほう｝で`xor`という｛基準｝｛きじゅん｝ブール
｛演算｝｛えんざん｝を｛実装｝｛じっそう｝してください。この
｛関数｝｛かんすう｝だけで、`fullAdder`という｛全加算器｝｛ぜんかさんき｝の
｛関数｝｛かんすう｝を｛定義｝｛ていぎ｝してください。

    fullAdder :: Bool          -- ｛入力｝｛にゅうりょく｝A
              -> Bool          -- ｛入力｝｛にゅうりょく｝B
              -> Bool          -- ｛桁上｝｛けたあ｝げ｛入力｝｛にゅうりょく｝
              -> (Bool, Bool)  -- (｛出力｝｛しゅつりょく｝, ｛桁上｝｛けたあ｝げ｛出力｝｛しゅつりょく｝)

http://ja.wikipedia.org/wiki/加算器

｛以下｝｛いか｝の｛使用例｝｛しようれい｝を｛示｝｛しめ｝してください。

    > fullAdder False False False
    (False, False)
    > fullAdder False True False
    (True, False)
    > fullAdder True True False
    (False, True)
    > fullAdder False False True
    (True, False)
    > fullAdder True False True
    (False, True)
    > fullAdder True True True
    (True, True)

｛問題｝｛もんだい｝12
----------------------

｛以下｝｛いか｝の｛関数｝｛かんすう｝をラムダ｛関数｝｛かんすう｝に
｛帰｝｛かえ｝す｛引数｝｛ひきすう｝ではないものに｛定義｝｛ていぎ｝
してください。

    lenCMtoIN :: Float -> Float
    lenCMtoIN cm = cm / 2.54

｛以下｝｛いか｝の｛使用例｝｛しようれい｝を｛示｝｛しめ｝してください。

    > lenCMtoIN 2.54
    1.0
    > lenCMtoIN 1
    0.39370078740157477

｛問題｝｛もんだい｝13
----------------------

｛以下｝｛いか｝の｛関数｝｛かんすう｝をラムダ｛関数｝｛かんすう｝に
｛帰｝｛かえ｝す｛引数｝｛ひきすう｝ではないものに｛定義｝｛ていぎ｝
してください。

    average :: Float -> Float -> Float
    average x y = (x + y) / 2

｛以下｝｛いか｝の｛使用例｝｛しようれい｝を｛示｝｛しめ｝してください。

    > average 1 10
    5.5
    > average 2 4
    3.0

｛問題｝｛もんだい｝14
----------------------

｛以下｝｛いか｝の｛関数｝｛かんすう｝をラムダ｛関数｝｛かんすう｝に
｛帰｝｛かえ｝す｛引数｝｛ひきすう｝ではないものに｛定義｝｛ていぎ｝
してください。

    bound :: (Int, Int) -> Int -> Int
    bound (low, high) x | x < low   = low
                        | x > high  = high
                        | otherwise = x

｛以下｝｛いか｝の｛使用例｝｛しようれい｝を｛示｝｛しめ｝してください。

    > bound (0,100) 101
    100
    > bound (32,212) 20
    32
    > bound (0,100) 99
    99

｛問題｝｛もんだい｝15
----------------------

ラムダ｛関数｝｛かんすう｝の｛代｝｛かわ｝わりにセクションを
｛使｝｛つか｝って、`lenCMtoIN`を｛定義｝｛ていぎ｝してください。

｛以下｝｛いか｝の｛使用例｝｛しようれい｝を｛示｝｛しめ｝してください。

    > lenCMtoIN 2.54
    1.0
    > lenCMtoIN 1
    0.39370078740157477

｛問題｝｛もんだい｝16
----------------------

｛以下｝｛いか｝のコードはピタゴラスの｛定理｝｛ていり｝で
｛直角｝｛ちょっかく｝｛三角形｝｛さんかっけい｝の｛斜辺｝｛しゃへん｝の
｛長｝｛なが｝さを｛計算｝｛けいさん｝する｛命令型｝｛めいれいがた｝
プログラミングの｛擬似｝｛ぎじ｝コード（｛別名｝｛べつめい｝Python）です。
Haskell｛版｝｛ばん｝を｛書｝｛か｝いてください。

    # ｛直角｝｛ちょっかく｝｛三角形｝｛さんかっけい｝の｛斜辺｝｛しゃへん｝の｛長｝｛なが｝さを｛計算｝｛けいさん｝する
    def pythag(a, b):
        return sqrt(a * a + b * b)

*Prelude*で｛定義｝｛ていぎ｝されている`sqrt :: Floating a => a -> a`
｛関数｝｛かんすう｝を｛使｝｛つか｝えます。

｛以下｝｛いか｝の｛使用例｝｛しようれい｝を｛示｝｛しめ｝してください。

    > pythag 3 4
    5.0
    > pythag 10 10
    14.142135623730951

｛問題｝｛もんだい｝17
----------------------

｛以下｝｛いか｝のコードはビネの｛式｝｛しき｝でフィボナッチ｛数｝｛すう｝を
｛計算｝｛けいさん｝する｛命令型｝｛めいれいがた｝プログラミングの
｛擬似｝｛ぎじ｝コード（｛別名｝｛べつめい｝Python）です。
`fib :: Int -> Int`というHaskell｛版｝｛ばん｝を｛書｝｛か｝いてください。

    # n｛番目｝｛ばんめ｝のフィボナッチ｛数｝｛すう｝を｛計算｝｛けいさん｝する
    def fib(n):
        root5 = sqrt(5)
        return round(((1 + root5) ** n - (1 - root5) ** n) / (2 ** n * root5))

*Prelude*で｛定義｝｛ていぎ｝されている`fromIntegral`と`round`という*Int*と
*Float*の｛値｝｛あたい｝を｛変換｝｛へんかん｝する｛関数｝｛かんすう｝を
｛使｝｛つか｝えます。

｛以下｝｛いか｝の｛使用例｝｛しようれい｝を｛示｝｛しめ｝してください。

    > fib 1
    1
    > fib 2
    1
    > fib 3
    2
    > fib 4
    3
    > fib 5
    5
    > fib 20
    6765
